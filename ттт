private void Update()
{
    if (!isMoving || splineObject == null || waypoints == null || waypoints.Count == 0)
        return;

    if (currentWaypointIndex >= waypoints.Count)
    {
        if (loopRoute)
        {
            currentWaypointIndex = 0;
        }
        else
        {
            isMoving = false;
            return;
        }
    }

    Node targetWaypoint = waypoints[currentWaypointIndex];
    if (targetWaypoint == null)
        return;

    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ splineObject (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
    vec3 targetPosition = targetWaypoint.WorldPosition; // –£–ë–†–ê–õ –ó–î–ï–°–¨ –ú–ò–ù–£–°
    vec3 currentPosition = splineObject.WorldPosition;

    vec3 direction = targetPosition - currentPosition;
    float distanceToTarget = MathLib.Length(direction);

    if (distanceToTarget < waypointThreshold)
    {
        if (currentWaypointIndex < waypoints.Count - 1)
        {
            currentWaypointIndex++;
        }
        else
        {
            if (loopRoute)
            {
                currentWaypointIndex = 0;
            }
            else
            {
                isMoving = false;
                return;
            }
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–ª—å –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π —Ç–æ—á–∫–∏
        if (currentWaypointIndex < waypoints.Count && waypoints[currentWaypointIndex] != null)
        {
            targetPosition = waypoints[currentWaypointIndex].WorldPosition;
            direction = targetPosition - currentPosition;
            distanceToTarget = MathLib.Length(direction);
        }
    }

    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ splineObject
    float speed = GetSpeed() * Game.IFps;
    vec3 moveDirection = MathLib.Normalize(direction);
    float maxMoveDistance = MathLib.Min(speed, distanceToTarget);
    vec3 newPosition = currentPosition + moveDirection * maxMoveDistance;
    splineObject.WorldPosition = newPosition;

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // üÜï –û–ë–ù–û–í–õ–ï–ù–ò–ï –í–†–ê–©–ï–ù–ò–Ø RotatingNodes –û–¢–ù–û–°–ò–¢–ï–õ–¨–ù–û –°–õ–ï–î–£–Æ–©–ï–ô –¢–û–ß–ö–ò
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    if (RotatingNodes != null && RotatingNodes.Count > 0)
    {
        vec3 lookTargetPos = targetPosition; // –ü–æ–∑–∏—Ü–∏—è —Å–ª–µ–¥—É—é—â–µ–π —Ç–æ—á–∫–∏

        foreach (var rotatingNode in RotatingNodes)
        {
            if (rotatingNode == null) continue;

            vec3 nodePos = rotatingNode.WorldPosition;
            vec3 nodeToTargetDir = lookTargetPos - nodePos;

            if (nodeToTargetDir.Length > 0.001f)
            {
                quat targetRotation = CalculateLookRotation(nodeToTargetDir);

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –æ–±—ä–µ–∫—Ç—É
                vec3 savedPos = rotatingNode.WorldPosition;
                vec3 savedScale = rotatingNode.WorldScale;

                rotatingNode.SetWorldRotation(targetRotation);

                rotatingNode.WorldPosition = savedPos;
                rotatingNode.WorldScale = savedScale;
            }
        }
    }
}
